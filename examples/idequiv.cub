module weq where

import univ

-- comTri : (A : U) (a b c : A) -> (ab : Id A a b) (bc : Id A b c) (ac : Id A a c) -> U
-- comTri A a b c ab bc ac = Id (Id A a c) (comp A a b c ab bc) ac

-- eqInFiber : (A B : U) (a a' : A) (b : B) -> (f : A -> B) ->
--             (q : Id B (f a) b) -> (q' : Id B b (f a')) -> (p : Id A a a') -> 
--             (ct : comTri B (f a) (f a') b (cong A B f a a' p) q' q) -> 
--             Id (fiber A B f b) (pair a q) (pair a' q')
-- eqInFiber A B a a' b f q q' ct = undefined

-- Proves that the identity is an equivalence


sId : (A : U) (a : A) -> pathTo A a
sId A a = pair a (refl A a)

tId : (A : U) (a : A) (v : pathTo A a) -> Id (pathTo A a) (sId A a) v
tId A a = split 
  pair x p -> rem x a p 
  where 
  rem : (x y : A) (p : Id A x y) -> Id (pathTo A y) (sId A y) (pair x p)
  rem x = J A x (\y p -> Id (pathTo A y) (sId A y) (pair x p)) (refl (pathTo A x) (sId A x))

eqU : Id U U U
eqU = equivEq U U (id U) (sId U) (tId U)

Bool' : U
Bool' = transport U U eqU Bool

eqBoolBool' : Id U Bool Bool'
eqBoolBool' = transpEquivEq U U (id U) (sId U) (tId U) Bool

eqBool'Bool : Id U Bool' Bool
eqBool'Bool = inv U Bool Bool' eqBoolBool'

True' : Bool'
True' = transport' Bool Bool' eqBoolBool' True

newTrue : Bool
newTrue = transport' Bool' Bool eqBool'Bool True'