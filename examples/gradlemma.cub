module gradlemma where

import equivprop

-- TODO: Debug import!
-- import idequiv

sId : (A : U) (a : A) -> pathTo A a
sId A a = pair a (refl A a)

tId : (A : U) (a : A) (v : pathTo A a) -> Id (pathTo A a) (sId A a) v
tId A a = split 
  pair x p -> rem x a p 
  where 
  rem : (x y : A) (p : Id A x y) -> Id (pathTo A y) (sId A y) (pair x p)
  rem x = J A x (\y p -> Id (pathTo A y) (sId A y) (pair x p)) (refl (pathTo A x) (sId A x))

corrstId : (A : U) (a : A) -> prop (fiber A A (id A) a)
corrstId A a v0 v1 = compInv (pathTo A a) (sId A a) v0 v1 (tId A a v0) (tId A a v1) 

corr2stId : (A : U) (h : A -> A) (ph : (x : A) -> Id A (h x) x) (a : A) -> 
            prop (fiber A A h a)
corr2stId A h ph a = substInv (A -> A) (\h -> prop (fiber A A h a)) h (id A) rem (corrstId A a)
  where 
  rem : Id (A -> A) h (id A)
  rem = funExt A (\_ -> A) h (id A) ph 

-- All of these lemmas on cong will be trivial with definitional equalities
congRefl : (A B : U) (f : A -> B) (a : A) -> 
           Id (Id B (f a) (f a)) (refl B (f a)) (cong A B f a a (refl A a))
congRefl A B f a = Jeq A a (\v p -> Id B (f a) (f v)) (refl B (f a))

congId : (A : U) (a0 a1 : A) -> 
         Id (Id A a0 a1 -> Id A a0 a1) (id (Id A a0 a1)) (cong A A (id A) a0 a1)
congId A a0 a1 = funExt (Id A a0 a1) (\_ -> Id A a0 a1) (id (Id A a0 a1)) 
                        (cong A A (id A) a0 a1) (rem a0 a1)
  where
  rem : (u0 u1 : A) -> (p : Id A u0 u1) -> Id (Id A u0 u1) p (cong A A (id A) u0 u1 p) 
  rem u0 = J A u0 (\u1 p -> Id (Id A u0 u1) p (cong A A (id A) u0 u1 p)) (rem1 u0)

  rem1 : (u : A) -> Id (Id A u u) (refl A u) (cong A A (id A) u u (refl A u))
  rem1 = congRefl A A (id A)

injId : (X : U) -> injective X X (id X)
injId X a0 a1 h = h

injCong : (A : U) (a0 a1 : A) -> injective (Id A a0 a1) (Id A a0 a1) (cong A A (id A) a0 a1)
injCong A a0 a1 = subst (X -> X) (\f -> injective X X f) 
                        (id X) (cong A A (id A) a0 a1) (congId A a0 a1) (injId X)
  where
  X : U
  X = Id A a0 a1

congComp : (A B C : U) (f : A -> B) (g : B -> C) (a0 a1 : A) -> 
           Id (Id A a0 a1 -> Id C (g (f a0)) (g (f a1))) 
              (cong A C (\x -> g (f x)) a0 a1)
              (\p -> cong B C g (f a0) (f a1) (cong A B f a0 a1 p))
congComp A B C f g a0 a1 = funExt (Id A a0 a1) (\_ -> Tgf a0 a1)
                                  (conggf a0 a1) (\p -> congg a0 a1 (congf a0 a1 p)) (rem a0 a1)
  where
  Tgf : (a0 a1 : A) -> U 
  Tgf a0 a1 = Id C (g (f a0)) (g (f a1))

  congf : (a0 a1 : A) -> Id A a0 a1 -> Id B (f a0) (f a1)
  congf = cong A B f
  
  congg : (a0 a1 : A) -> Id B (f a0) (f a1) -> Tgf a0 a1
  congg a0 a1 = cong B C g (f a0) (f a1)

  conggf : (a0 a1 : A) -> Id A a0 a1 -> Tgf a0 a1
  conggf = cong A C (\x -> g (f x))

  rem : (a0 a1 : A) (p : Id A a0 a1) -> 
        Id (Tgf a0 a1) (conggf a0 a1 p) (congg a0 a1 (congf a0 a1 p))
  rem a = J A a (\a1 p -> Id (Tgf a a1) (conggf a a1 p) (congg a a1 (congf a a1 p)))
             rem1
    where
    rem1 : Id (Tgf a a) (conggf a a (refl A a)) (congg a a (congf a a (refl A a)))
    rem1 = lemTrans (Tgf a a) (refl C (g (f a))) (conggf a a (refl A a))
                              (congg a a (refl B (f a))) (congg a a (congf a a (refl A a)))
                    rem2 rem3 rem5

    rem2 : Id (Tgf a a) (refl C (g (f a))) (conggf a a (refl A a))
    rem2 = congRefl A C (\x -> g (f x)) a

    rem3 : Id (Tgf a a) (congg a a (refl B (f a))) (congg a a (congf a a (refl A a)))
    rem3 = cong (Id B (f a) (f a)) (Tgf a a) (congg a a) (refl B (f a)) 
                (congf a a (refl A a)) rem4

    rem4 : Id (Id B (f a) (f a)) (refl B (f a)) (congf a a (refl A a))
    rem4 = congRefl A B f a

    rem5 : Id (Tgf a a) (refl C (g (f a))) (congg a a (refl B (f a)))
    rem5 = congRefl B C g (f a)


injComp : (A B C : U) (f : A -> B) (g : B -> C) -> injective A C (\x -> g (f x)) -> 
          injective A B f
injComp A B C f g injgf a0 a1 p = injgf a0 a1 rem
  where
  rem : Id C (g (f a0)) (g (f a1))
  rem = cong B C g (f a0) (f a1) p

lemProp1 : (A : U) -> (A -> prop A) -> prop A
lemProp1 A h a0 = h a0 a0

injProp : (A B : U) (f : A -> B) -> injective A B f -> prop B -> prop A
injProp A B f injf pB a0 a1 = injf a0 a1 (pB (f a0) (f a1))

congRetract : (A B : U) (f : A -> B) (g : B -> A) -> retract A B f g -> (a0 a1 : A) -> 
              injective (Id A a0 a1) (Id B (f a0) (f a1)) (cong A B f a0 a1)
congRetract A B f g rfg a0 a1 = rem
  where
  TA : U
  TA = Id A a0 a1

  TB : U
  TB = Id B (f a0) (f a1)

  cf : TA -> TB 
  cf = cong A B f a0 a1

  TC : U 
  TC = Id A (g (f a0)) (g (f a1))

  cg : TB -> TC
  cg = cong B A g (f a0) (f a1)

  cgf : TA -> TC
  cgf = cong A A (\x -> g (f x)) a0 a1

  rem : injective TA TB cf
  rem = injComp TA TB TC cf cg rem1

  rem1 : injective TA TC (\p -> cg (cf p))
  rem1 = subst (TA -> TC) (injective TA TC) cgf (\p -> cg (cf p)) rem2 rem3

  rem2 : Id (TA -> TC) cgf (\p -> cg (cf p))
  rem2 = congComp A B A f g a0 a1

  rem3 : injective TA TC cgf
  rem3 = substInv (A -> A) (\h -> injective TA (Id A (h a0) (h a1)) (cong A A h a0 a1)) 
                  (\x -> g (f x)) (id A) rem4 rem5 

  rem4 : Id (A -> A) (\x -> g (f x)) (id A)
  rem4 = funExt A (\_ -> A) (\x -> g (f x)) (id A) rfg

  rem5 : injective TA TA (cong A A (id A) a0 a1)
  rem5 = injCong A a0 a1


contr : U -> U
contr A = Id U Unit A

propContr : (A : U) -> A -> prop A -> contr A
propContr A a pA = propExt Unit A propUnit pA (\_ -> a) (\_ -> tt)

isEquiv : (A B : U) (f : A -> B) -> U
isEquiv A B f = Sigma ((y : B) -> fiber A B f y) 
                      (\s -> (y : B) -> (v : fiber A B f y) -> Id (fiber A B f y) (s y) v)


isEquivEq : (A B : U) (f : A -> B) -> isEquiv A B f -> Id U A B
isEquivEq A B f = split 
  pair s t -> equivEq A B f s t

isEquivSection : (A B : U) (f : A -> B) (g : B -> A) -> section A B f g -> 
                 ((b : B) -> prop (fiber A B f b)) -> isEquiv A B f
isEquivSection A B f g sfg h = pair s t
  where
  s : (y : B) -> fiber A B f y
  s y = pair (g y) (sfg y)

  t : (y : B) -> (v : fiber A B f y) -> Id (fiber A B f y) (s y) v
  t y v = h y (s y) v


gradLemma : (A B : U) (f : A -> B) (g : B -> A) -> section A B f g -> retract A B f g -> 
            isEquiv A B f
gradLemma A B f g sfg rfg = isEquivSection A B f g sfg rem
  where
  injf : injective A B f
  injf = retractInj A B f g rfg

  rem : (b : B) -> prop (Sigma A (\a -> Id B (f a) b))
  rem b = lemEqSigma A (\a -> Id B (f a) b) rem1 rem2
    where
    rem1 : (a : A) -> prop (Id B (f a) b)
    rem1 = undefined -- TODO

    rem2 : (a0 a1 : A) -> Id B (f a0) b -> Id B (f a1) b -> Id A a0 a1
    rem2 a0 a1 p0 p1 = injf a0 a1 (idEuclid B (f a0) (f a1) b p0 p1)

