module testprim where

import primitive

subst' : (A : U) (P : A -> U) (a x : A) (p : Id A a x) -> P a -> P x
subst' A P a x p d = J A a (\ x q -> P x) d x p

subst'eq : (A : U) (P : A -> U) (a : A) (d : P a) ->
          Id (P a) d (subst' A P a a (refl A a) d)
subst'eq A P a d = Jeq A a (\ x q -> P x) d

cong : (A B : U) (f : A -> B) (a b : A) (p : Id A a b) -> Id B (f a) (f b)
cong A B f a b p = subst' A (\x -> Id B (f a) (f x)) a b p (refl B (f a))

UIP : U -> U
UIP A = (a b : A) -> (p q : Id A a b) -> Id (Id A a b) p q

comp : (A : U) -> (a b c : A) -> Id A a b -> Id A b c -> Id A a c
comp A a b c p q = subst' A (Id A a) b c q p


compInvIdr : (A : U) -> (a b : A) -> (p : Id A a b) -> Id (Id A a b) p (comp A a b b p (refl A b))
compInvIdr A a b p = subst'eq A (\x -> Id A a x) b p

inv : (A : U) -> (a b :A) -> Id A a b -> Id A b a
inv A a b p = subst' A (\ x -> Id A x a) a b p (refl A a)


compIdr : (A : U) -> (a b : A) -> (p : Id A a b) -> Id (Id A a b) (comp A a b b p (refl A b)) p
compIdr A a b p = inv (Id A a b) p (comp A a b b p (refl A b)) (compInvIdr A a b p)

compInvIdl : (A : U) -> (b c : A) -> (q : Id A b c) ->
          Id (Id A b c) q (comp A b b c (refl A b) q)
compInvIdl A b c q = J A b (\c q -> Id (Id A b c) q (comp A b b c (refl A b) q)) rem c q
  where
    rem : Id (Id A b b) (refl A b) (comp A b b b (refl A b) (refl A b))
    rem = compInvIdr A b b (refl A b)


compIdl : (A : U) -> (b c : A) -> (q : Id A b c) ->
             Id (Id A b c) (comp A b b c (refl A b) q) q
compIdl A b c q = inv (Id A b c) q (comp A b b c (refl A b) q) (compInvIdl A b c q)

compInv : (A : U) -> (a b c : A) -> Id A a b -> Id A a c -> Id A b c
compInv A a b c p r = subst' A (\ x -> Id A x c) a b p r

compInvIdl' : (A : U) (a b : A) (p : Id A a b) ->
               Id (Id A a b) p (compInv A a a b (refl A a) p)
compInvIdl' A a b p = subst'eq A (\x -> Id A x b) a p

rel : U -> U
rel A = A -> A -> U

euclidean : (A : U) -> rel A -> U
euclidean A R = (a b c : A) -> R a c -> R b c -> R a b

idEuclid : (A : U) -> euclidean A (Id A)
idEuclid A a b c p r = comp A a c b p (inv A b c r)

lemTrans : (A:U) -> (a a' b b':A) -> Id A a a' -> Id A b b' -> Id A a b -> Id A a' b'
lemTrans A a a' b b' p q r =
 subst' A (\ x -> Id A x b') a a' p rem
 where
  rem : Id A a b'
  rem = comp A a b b' r q


lem2Trans : (A:U) -> (a a' b b':A) -> Id A a a' -> Id A b b' -> Id A a' b' -> Id A a b
lem2Trans A a a' b b' p q r =
 subst' A (\ x -> Id A a x) b' b (inv A b b' q) rem
 where
  rem : Id A a b'
  rem = comp A a a' b' p r

lemInv : (A:U) -> (a b c : A) -> (p : Id A a b) -> (q : Id A b c) ->
         Id (Id A b c) q (compInv A a b c p (comp A a b c p q))
lemInv A a b c p q =
 J A a (\ b p -> (c : A) (q : Id A b c) ->
        Id (Id A b c) q (compInv A a b c p (comp A a b c p q))) rem b p c q
 where
  rem1 : (c : A) (q : Id A a c) ->
          Id (Id A a c) (comp A a a c (refl A a) q)
                        (compInv A a a c (refl A a) (comp A a a c (refl A a) q))
  rem1 c q = compInvIdl' A a c (comp A a a c (refl A a) q)

  rem2 : (c : A) (q : Id A a c) -> Id (Id A a c) q (comp A a a c (refl A a) q)
  rem2 c q = compInvIdl A a c q

  rem : (c : A) (q : Id A a c) ->
          Id (Id A a c) q (compInv A a a c (refl A a) (comp A a a c (refl A a) q))
  rem c q = comp (Id A a c) q
                        (comp A a a c (refl A a) q)
                        (compInv A a a c (refl A a) (comp A a a c (refl A a) q))
                        (rem2 c q)
                        (rem1 c q)


lemSimpl : (A:U) -> (a b c : A) -> (p : Id A a b) -> (q q' : Id A b c) ->
   Id (Id A a c) (comp A a b c p q) (comp A a b c p q') -> Id (Id A b c) q q'
lemSimpl A a b c p q q' h =
 lem2Trans (Id A b c)
           q (compInv A a b c p (comp A a b c p q)) q' (compInv A a b c p (comp A a b c p q'))
           rem rem1 rem2
 where
   rem : Id (Id A b c) q (compInv A a b c p (comp A a b c p q))
   rem = lemInv A a b c p q

   rem1 : Id (Id A b c) q' (compInv A a b c p (comp A a b c p q'))
   rem1 = lemInv A a b c p q'

   rem2 : Id (Id A b c) (compInv A a b c p (comp A a b c p q))
                        (compInv A a b c p (comp A a b c p q'))
   rem2 = cong (Id A a c) (Id A b c) (compInv A a b c p)
               (comp A a b c p q) (comp A a b c p q') h


lem1 : (A :U) -> (a:A) -> (h : (x:A) -> Id A a x) ->
       (x y : A) -> (p : Id A x y) -> Id (Id A a y) (comp A a x y (h x) p) (h y)
lem1 A a h x =
  J A x (\ y p -> Id (Id A a y) (comp A a x y (h x) p) (h y)) rem
 where
   rem : Id (Id A a x) (comp A a x x (h x) (refl A x)) (h x)
   rem = compIdr A a x (h x)

lem2 : (A :U) -> (a:A) -> ((x:A) -> Id A a x) -> UIP A
lem2 A a h x y p q =
 lemSimpl A a x y (h x) p q rem
   where
     remp : Id (Id A a y) (comp A a x y (h x) p) (h y)
     remp = lem1 A a h x y p
     remq : Id (Id A a y) (comp A a x y (h x) q) (h y)
     remq = lem1 A a h x y q
     rem : Id (Id A a y) (comp A a x y (h x) p) (comp A a x y (h x) q)
     rem = lem2Trans (Id A a y) (comp A a x y (h x) p) (h y) (comp A a x y (h x) q) (h y)
               remp remq (refl (Id A a y) (h y))

propUIP : (A:U) -> prop A -> UIP A
propUIP A h a = lem2 A a (h a) a

Unit : U
data Unit = tt

propUnit : prop Unit
propUnit = split
  tt -> split
     tt -> refl Unit (tt)

lemunit : UIP Unit
lemunit = propUIP Unit propUnit

test2 : Id (Id Unit (tt) (tt)) (refl Unit (tt)) (refl Unit (tt))
test2 = lemunit (tt) (tt) (refl Unit (tt)) (refl Unit (tt))

inhuip : (A : U) -> UIP (inh A)
inhuip A = propUIP (inh A) (squash A)

N : U
data N = zero | suc (n : N)

zz : inh N
zz = inc N (zero)

eq1 : Id (inh N) zz zz
eq1 = refl (inh N) zz

eq2 : Id (inh N) zz zz
eq2 = squash N zz zz

test : Id (Id (inh N) zz zz) eq1 eq2
test = inhuip N zz zz eq1 eq2

N0 : U
data N0 =

neg : U -> U
neg A = A -> N0

efq : (A : U) -> N0 -> A
efq A = split {}

or : U -> U -> U
data or A B = inl (a : A) | inr (b : B)

dec : U -> U
dec A = or A (neg A)

graph : (A B : U) -> (f : A -> B) -> B -> A -> U
graph A B f y x = Id B (f x) y

const : (A : U) (f : A -> A) -> U
const A f = (x y : A) -> Id A (f x) (f y)

exConst : (A : U) -> U
exConst A = Sigma (A -> A) (const A)

decConst : (A : U) -> dec A -> exConst A
decConst A = split
  inl a -> pair (\x -> a) (\ x y -> refl A a)
  inr h -> pair (\x -> x) (\ x y -> efq (Id A x y) (h x))


mainLemma : (A: U) (f : (a b : A) -> Id A a b -> Id A a b) (a b : A)
            (p : Id A a b) ->
            Id (Id A a b) (comp A a a b (f a a (refl A a)) p) (f a b p)
mainLemma A f a = J A a (\ b p -> Id (Id A a b) (comp A a a b (f a a (refl A a)) p) (f a b p)) rem
  where rem : Id (Id A a a) (comp A a a a (f a a (refl A a)) (refl A a)) (f a a (refl A a))
        rem = compIdr A a a (f a a (refl A a))

discrete : U -> U
discrete A = (a b : A) -> dec (Id A a b)

fst : (A : U) (B : A -> U) -> Sigma A B -> A
fst A B = split
  pair a b -> a

snd : (A : U) (B : A -> U) (p : Sigma A B) -> B (fst A B p)
snd A B = split
  pair a b -> b

hedberg : (A : U) -> discrete A -> UIP A
hedberg A h a b p q = lemSimpl A a a b r p q rem5
  where
    rem1 : (x y : A) -> exConst (Id A x y)
    rem1 x y = decConst (Id A x y) (h x y)

    f : (x y : A) -> Id A x y -> Id A x y
    f x y = fst (Id A x y -> Id A x y) (const (Id A x y)) (rem1 x y)

    fisconst : (x y : A) -> const (Id A x y) (f x y)
    fisconst x y = snd (Id A x y -> Id A x y) (const (Id A x y)) (rem1 x y)

    r : Id A a a
    r = f a a (refl A a)

    rem2 : Id (Id A a b) (comp A a a b r p) (f a b p)
    rem2 = mainLemma A f a b p

    rem3 : Id (Id A a b) (comp A a a b r q) (f a b q)
    rem3 = mainLemma A f a b q

    rem4 : Id (Id A a b) (f a b p) (f a b q)
    rem4 = fisconst a b p q

    rem5 : Id (Id A a b) (comp A a a b r p) (comp A a a b r q)
    rem5 = lem2Trans (Id A a b) (comp A a a b r p) (f a b p) (comp A a a b r q) (f a b q) rem2 rem3 rem4



znots : (n : N) -> neg (Id N (zero) (suc n))
znots n h = subst' N T (zero) (suc n) h (zero)
  where
    T : N -> U
    T = split
          zero -> N
          suc n -> N0

snotz : (n : N) -> neg (Id N (suc n) (zero))
snotz n h = znots n (inv N (suc n) (zero) h)

pred : N -> N
pred = split
  zero -> zero
  suc n -> n

sucInj : (n m : N) -> Id N (suc n) (suc m) -> Id N n m
sucInj n m h = cong N N pred (suc n) (suc m) h

sucCong : (n m : N) -> Id N n m -> Id N (suc n) (suc m)
sucCong n m h = cong N N (\n -> suc n) n m h

decEqCong : (A B : U) (f : A -> B) (g : B -> A) -> dec A -> dec B
decEqCong A B f g = split
  inl a -> inl (f a)
  inr h -> inr (\b -> h (g b))


natDec : discrete N
natDec = split
  zero  -> split
    zero -> rem
      where rem : dec (Id N (zero) (zero))
            rem = inl (refl N (zero))
    suc m -> inr (znots m)
  suc n -> split
    zero -> inr (snotz n)
    suc m -> decEqCong (Id N n m) (Id N (suc n) (suc m))
                       (sucCong n m) (sucInj n m) (natDec n m)

NIsSet : UIP N
NIsSet = hedberg N natDec

test3 : Id (Id N (zero) (zero)) (refl N (zero)) (refl N (zero))
test3 = NIsSet (zero) (zero) (refl N (zero)) (refl N (zero))

Bool : U
data Bool = true | false

tnotf : neg (Id Bool (true) (false))
tnotf h = subst' Bool T (true) (false) h (zero)
  where
    T : Bool -> U
    T = split
          true  -> N
          false -> N0

fnott : neg (Id Bool (false) (true))
fnott h = tnotf (inv Bool (false) (true) h)


boolDec : discrete Bool
boolDec = split
  true -> split
    true -> inl (refl Bool (true))
    false -> inr tnotf
  false -> split
    true -> inr fnott
    false -> inl (refl Bool (false))


boolIsSet : UIP Bool
boolIsSet = hedberg Bool boolDec

eqSigma : (A : U) (B : A -> U) (a b : A) (p : Id A a b)
          (u : B a) (v : B b) (q : Id (B b) (subst' A B a b p u) v) ->
          Id (Sigma A B) (pair a u) (pair b v)
eqSigma A B a =
  J A a (\b p -> (u : B a) (v : B b) (q : Id (B b) (subst' A B a b p u) v) ->
         Id (Sigma A B) (pair a u) (pair b v)) rem2
  where
    rem1 : (u v : B a) -> Id (B a) u v ->
           Id (Sigma A B) (pair a u) (pair a v)
    rem1 = cong (B a) (Sigma A B) (\x -> pair a x)

    rem2 : (u v : B a) -> Id (B a) (subst' A B a a (refl A a) u) v ->
           Id (Sigma A B) (pair a u) (pair a v)
    rem2 u v q = rem1 u v q'
      where q' : Id (B a) u v
            q' = comp (B a) u (subst' A B a a (refl A a) u) v (subst'eq A B a u) q

lemEqSigma : (A : U) (B : A -> U) -> ((a : A) -> prop (B a)) -> 
             ((a0 a1 : A) -> B a0 -> B a1 -> Id A a0 a1) -> 
             prop (Sigma A B)
lemEqSigma A B pB uB = split
  pair a0 b0 -> split 
    pair a1 b1 -> eqSigma A B a0 a1 rem b0 b1 rem1
  where
  rem : Id A a0 a1
  rem = uB a0 a1 b0 b1
  
  rem1 : Id (B a1) (subst' A B a0 a1 rem b0) b1
  rem1 = pB a1 (subst' A B a0 a1 rem b0) b1

propFam : (A : U) (B : A -> U) -> U
propFam A B = (a : A) -> prop (B a)

eqPropFam : (A : U) (B : A -> U) (h : propFam A B) (au bv : Sigma A B) ->
            Id A (fst A B au) (fst A B bv) -> Id (Sigma A B) au bv
eqPropFam A B h = split
  pair a u -> split
    pair b v -> \p -> eqSigma A B a b p u v (h b (subst' A B a b p u) v)

exist : (A : U) (B : A -> U) -> U
exist A B = inh (Sigma A B)

-- TODO: fix parser for "Fun"
exElim : (A : U) (B : A -> U) (C : U) -> prop C -> (Sigma A B -> C) ->
         exist A B -> C
exElim A B C p f = inhrec (Sigma A B) C p f

atmostOne : (A : U) (B : A -> U) -> U
atmostOne A B = (a b : A) -> B a -> B b -> Id A a b

propSig : (A : U) (B : A -> U) -> propFam A B -> atmostOne A B ->
          prop (Sigma A B)
propSig A B h h' au bv =
  eqPropFam A B h au bv (h' (fst A B au) (fst A B bv) (snd A B au) (snd A B bv))

and : (A B : U) -> U
and A B = Sigma A (\_ -> B)

exactOne : (A : U) (B : A -> U) -> U
exactOne A B = and (exist A B) (atmostOne A B)

lemInh : (A : U) -> prop A -> inh A -> A
lemInh A h = inhrec A A h (\x -> x)

descrAx : (A : U) (B : A -> U) -> propFam A B -> exactOne A B -> Sigma A B
descrAx A B h = split
  pair g h' -> lemInh (Sigma A B) rem g
  where rem : prop (Sigma A B)
        rem = propSig A B h h'

iota : (A : U) (B : A -> U) (h : propFam A B) (h' : exactOne A B) -> A
iota A B h h' = fst A B (descrAx A B h h')

iotaSound : (A : U) (B : A -> U) (h : propFam A B) (h' : exactOne A B) -> B (iota A B h h')
iotaSound A B h h' = snd A B (descrAx A B h h')

exAtOne : (A : U) (B : A -> U) -> exactOne A B -> atmostOne A B
exAtOne A B = split
  pair g h' -> h'


iotaLem : (A : U) (B : A -> U) (h : propFam A B) (h' : exactOne A B) ->
          (a : A) -> B a -> Id A a (iota A B h h')
iotaLem A B h h' a p = exAtOne A B h' a (iota A B h h') p (iotaSound A B h h')

reflexive : (A : U) -> rel A -> U
reflexive A R = (a : A) -> R a a

symmetry : (A : U) -> rel A -> U
symmetry A R = (a b : A) -> R a b -> R b a

equivalence : (A : U) -> rel A -> U
equivalence A R = and (reflexive A R) (euclidean A R)

eqToRefl : (A : U) (R : rel A) -> equivalence A R -> reflexive A R
eqToRefl A R = split
  pair r _ -> r

eqToEucl : (A : U) (R : rel A) -> equivalence A R -> euclidean A R
eqToEucl A R = split
  pair _ e -> e

eqToSym : (A : U) (R : rel A) -> equivalence A R -> symmetry A R
eqToSym A R = split
  pair r e -> \a b -> e b a b (r b)

eqToInvEucl : (A : U) (R : rel A) -> equivalence A R ->
              (a b c : A) -> R c a -> R c b -> R a b
eqToInvEucl A R eq a b c p q =
  eqToEucl A R eq a b c (eqToSym A R eq c a p) (eqToSym A R eq c b q)

--test13 : (A : U) (R : rel A) (P : A -> U) -> U
--test13 A R P = propFam A P


Quot : (A : U) (R : rel A) -> U
data Quot A R =
  class (P : A -> U)
        (un : (a b : A) -> P a -> P b -> R a b)
        (cp : (a b : A) -> P a -> R a b -> P b)
        (ex : exist A P)
        (pr : propFam A P)

propRel : (A : U) (R : rel A) -> U
propRel A R = (a b : A) -> prop (R a b)

canSurj : (A : U) (R : rel A) -> equivalence A R -> propRel A R ->
            A -> Quot A R
canSurj A R h h' c = class (R c) un cp ex pr
  where un : (a b : A) -> R c a -> R c b -> R a b
        un a b p q = eqToInvEucl A R h a b c p q

        cp : (a b : A) -> R c a -> R a b -> R c b
        cp a b p q = eqToEucl A R h c b a p (eqToSym A R h a b q)
        ex : exist A (R c)
        ex = inc (Sigma A (R c)) (pair c (eqToRefl A R h c))
        pr : propFam A (R c)
        pr a = h' c a

resp : (A B : U) (R : rel A) (f : A -> B) -> U
resp A B R f = (x y : A) -> R x y -> Id B (f x) (f y)

image : (A B : U) (f : A -> B) (P : A -> U) -> B -> U
image A B f P b = exist A (\a -> and (P a) (Id B (f a) b))

propAnd : (A B : U) -> prop A -> prop B -> prop (and A B)
propAnd A B p q = propSig A F rem (\a a' _ _ -> p a a')
  where F : A -> U
        F a = B
        rem : propFam A F
        rem a = q

univQuot : (A B : U) (R : rel A) (f : A -> B) ->
           UIP B -> resp A B R f -> (eqR : equivalence A R) (pR : propRel A R)
--         Sigma
                 (_ : Quot A R) -> B
--               (\g -> (a : A) -> Id B (f a) (g (canSurj A R eqR pR a)))
univQuot A B R f uip fresp eqR pR = g -- pair g rem
  where
    g : Quot A R -> B
    g = split
      class P un cp ex pr -> iota B imfP rem1 rem2
        where
          imfP : B -> U
          imfP = image A B f P
          rem1 : propFam B imfP
          rem1 b = squash (Sigma A (\a -> and (P a) (Id B (f a) b)))
          S : B -> A -> U
          S b a = and (P a) (Id B (f a) b)

          rem3 : Sigma A P -> exist B imfP
          rem3 = split
            pair a p -> inc (Sigma B imfP)
                        (pair (f a) (inc (Sigma A (S (f a))) (pair a (pair p (refl B (f a))))))
          rem4 : exist B imfP
          rem4 = inhrec (Sigma A P) (exist B imfP) (squash (Sigma B imfP)) rem3 ex

          rem6 : (b b' : B) (a a' : A) (_ : and (P a) (Id B (f a) b))
             (_ : and (P a') (Id B (f a') b')) -> Id B b b'
          rem6 b b' a a' = split
            pair p ea -> split
              pair p' ea' -> lemTrans B (f a) b (f a') b' ea ea' rem7
                where rem8 : R a a'
                      rem8 = un a a' p p'
                      rem7 : Id B (f a) (f a')
                      rem7 = fresp a a' rem8
                     
          rem7 : (b b' : B)  (_ : Sigma A (S b)) (_ : Sigma A (S b'))
             -> Id B b b'
          rem7 b b' = split
            pair a p -> split
              pair a' p' -> rem6 b b' a a' p p'

          rem8 : (b b' : B) -> Sigma A (S b) -> exist A (S b') -> Id B b b'
          rem8 b b' h = exElim A (S b') (Id B b b') (uip b b') (rem7 b b' h)

          rem9 : (b b' : B) -> exist A (S b) -> exist A (S b') -> Id B b b'
          rem9 b b' h h' = exElim A (S b) (Id B b b') (uip b b')
                        (\h'' -> rem8 b b' h'' h') h

          rem5 : atmostOne B imfP
          rem5 = rem9

          rem2 : exactOne B imfP
          rem2 = pair rem4 rem5


kernel : (A B : U) (f : A -> B) -> rel A
kernel A B f a a' = Id B (f a) (f a')

kerRef : (A B : U) (f : A -> B) -> reflexive A (kernel A B f)
kerRef A B f a = refl B (f a)

kerEucl : (A B : U) (f : A -> B) -> euclidean A (kernel A B f)
kerEucl A B f a b c p q = compInv B (f c) (f a) (f b) rem rem1
 where rem : Id B (f c) (f a)
       rem = inv B (f a) (f c) p
       rem1 : Id B (f c) (f b)
       rem1 = inv B (f b) (f c) q

kerEquiv : (A B : U) (f : A -> B) -> equivalence A (kernel A B f)
kerEquiv A B f = pair (kerRef A B f) (kerEucl A B f)

not : Bool -> Bool
not = split
  true -> false
  false -> true


isEven : N -> Bool
isEven = split
  zero -> true
  suc n -> not (isEven n)

mod2 : rel N
mod2 = kernel N Bool isEven

propMod2 : propRel N mod2
propMod2 n m = boolIsSet (isEven n) (isEven m)

Z2 : U
Z2 = Quot N mod2

respIsEven : resp N Bool mod2 isEven
respIsEven n m h = h

barIsEven : Z2 -> Bool
barIsEven = univQuot N Bool mod2 isEven boolIsSet respIsEven (kerEquiv N Bool isEven) propMod2


five : N
five = suc (suc (suc (suc  (suc (zero)))))

fiveBar : Z2
fiveBar = canSurj N mod2 (kerEquiv N Bool isEven) propMod2 five

test5 : Bool
test5 = barIsEven fiveBar


notK : (x : Bool) -> Id Bool (not (not x)) x
notK = split
  true  -> refl Bool (true)
  false -> refl Bool (false)

notInj : (x y : Bool) -> Id Bool (not x) (not y) -> Id Bool x y
notInj x y p = lemTrans Bool (not (not x)) x (not (not y)) y (notK x) (notK y) rem
  where
  rem : Id Bool (not (not x)) (not (not y))
  rem = cong Bool Bool not (not x) (not y) p

notFiber : Bool -> U
notFiber b = fiber Bool Bool not b

fstNotFiber : (b : Bool) -> notFiber b -> Bool
fstNotFiber b = fst Bool (\x -> Id Bool (not x) b)

eqNotFiber : (b : Bool) -> (v v' : notFiber b) ->
  Id Bool (fstNotFiber b v) (fstNotFiber b v') -> Id (notFiber b) v v'
eqNotFiber b = eqPropFam Bool (\x -> Id Bool (not x) b) rem
  where
  rem : propFam Bool (\x -> Id Bool (not x) b)
  rem = \x -> boolIsSet (not x) b

sNot : (b : Bool) -> notFiber b
sNot b = pair (not b) (notK b)

tNot : (b : Bool) (v : notFiber b) -> Id (notFiber b) (sNot b) v
tNot b v = eqNotFiber b (sNot b) v rem
  where
  b' : Bool
  b' = fstNotFiber b v

  rem1 : Id Bool (not (not b)) (not b')
  rem1 = comp Bool (not (not b)) b (not b') (notK b)
         (inv Bool (not b') b (snd Bool (\x -> Id Bool (not x) b) v))

  rem : Id Bool (not b) b'
  rem = notInj (not b) b' rem1

eqBoolBool : Id U Bool Bool
eqBoolBool = equivEq Bool Bool not sNot tNot

-- transport : (A B : U) -> Id U A B -> A -> B
-- transport = subst U (\x -> x)

transportInv : (A B : U) -> Id U A B -> B -> A
transportInv = substInv U (\x -> x)

notEqBool : Bool -> Bool
notEqBool = transport Bool Bool eqBoolBool

testBool : Bool
testBool = notEqBool (true)

compEqBool : Id U Bool Bool
compEqBool = comp U Bool Bool Bool eqBoolBool eqBoolBool

transport' : (A B : U) -> Id U A B -> A -> B
transport' = subst' U (\x -> x)

funCompEqBool : Bool -> Bool
funCompEqBool = transport' Bool Bool compEqBool

newTestBool : Bool
newTestBool = funCompEqBool (true)

newCompEqBool : Id U Bool Bool
newCompEqBool = comp U Bool Bool Bool eqBoolBool (refl U Bool)

test2Bool : Bool
test2Bool = transport' Bool Bool newCompEqBool (true)

monoid : U -> U
monoid A = and A (A -> A -> A)

zm : (A : U) (m : monoid A) -> A
zm A m = fst A (\x -> A -> A -> A) m

opm : (A : U) (m : monoid A) -> (A -> A -> A)
opm A m = snd A (\x -> A -> A -> A) m

transm : (A B : U) -> Id U A B -> monoid A -> monoid B
transm = subst' U monoid 

transun : (A B : U) -> Id U A B -> (A -> A) -> (B -> B)
transun = subst' U (\X -> (X -> X))

transid : Bool -> Bool
transid = transun Bool Bool eqBoolBool (\x -> x)

True : Bool
True = true

False : Bool
False = false

testT : Bool
testT = transid True

testT' : Bool
testT' = transun Bool Bool (refl U Bool) (\x -> x) True

testF : Bool
testF = transid False

andBool : Bool -> Bool -> Bool
andBool = split
  true -> \x -> x
  false -> \x -> false

monoidAndBool : monoid Bool
monoidAndBool = pair (true) andBool

mBool2 : monoid Bool
mBool2 = transm Bool Bool eqBoolBool monoidAndBool

opBool2 : Bool -> Bool -> Bool
opBool2 = opm Bool mBool2

testTF : Bool
testTF = opBool2 True False

testFT : Bool
testFT = opBool2 False True

testFF : Bool
testFF = opBool2 False False

testTT : Bool
testTT = opBool2 True True



--  subst : (A : U) (P : A -> U) (a x : A) (p : Id A a x) -> P a -> P x

-- transportLem : (A B : U) (p : Id U A B) (a : A) (f : A -> B) -> 

negUIP : neg (UIP U)
negUIP uipU = tnotf lem5
  where
  eqreflnot : Id (Id U Bool Bool) (refl U Bool) eqBoolBool
  eqreflnot = uipU Bool Bool (refl U Bool) eqBoolBool

  frefl : Bool -> Bool
  frefl = transport Bool Bool (refl U Bool)

  fnot : Bool -> Bool
  fnot = transport Bool Bool eqBoolBool

  lem1 : Id (Bool -> Bool) frefl fnot
  lem1 = cong (Id U Bool Bool) (Bool -> Bool) (transport Bool Bool) 
              (refl U Bool) eqBoolBool eqreflnot

  lem2 : Id Bool true (frefl true)
  lem2 = transportRef Bool true

  lem3 : Id Bool false (fnot true)
  lem3 = transpEquivEq Bool Bool not sNot tNot true

  lem4 : Id Bool (frefl true) (fnot true)
  lem4 = cong (Bool -> Bool) Bool (\f -> f true) frefl fnot lem1

  lem5 : Id Bool true false
  lem5 = lem2Trans Bool true (frefl true) false (fnot true) lem2 lem3 lem4

--- simple test

andCong : (A B C:U) -> Id U B C -> Id U (and A B) (and A C)
andCong A = cong U U (and A)

eqST1 : Id U (and U N) (and U N) 
eqST1 = andCong U N N (refl U N)

tST1 : (and U N) -> (and U N)
tST1 = transport (and U N) (and U N) eqST1

t110 : U
t110 =  fst U (\ _ -> N) (tST1 (pair Bool zero))
