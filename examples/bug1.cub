module weq where

primitive
  Id   : (A : U) (a b : A) -> U
  refl : (A : U) (a : A) -> Id A a a
  J : (A : U) (a : A) -> (C : (x : A) -> Id A a x -> U) -> C a (refl A a) ->
      (x : A) -> (p : Id A a x) -> C x p
  equivEq : (A B : U) (f : A -> B) (s : (y : B) -> fiber A B f y)
            (t : (y : B) -> (v : fiber A B f y) -> Id (fiber A B f y) (s y) v) ->
            Id U A B
  subst : (A : U) (P : A -> U) (a x : A) (p : Id A a x) -> P a -> P x
  transport : (A B : U) -> Id U A B -> A -> B
  transportRef : (A : U) -> (a : A) -> Id A a (transport A A (refl U A) a)
  transpEquivEq : (A B : U) -> (f : A -> B) (s : (y : B) -> fiber A B f y) -> 
                  (t : (y : B) -> (v : fiber A B f y) -> Id (fiber A B f y) (s y) v) ->
                  (a : A) -> Id B (f a) (transport A B (equivEq A B f s t) a)

data Sigma (A : U) (B : A -> U) = pair (x : A) (y : B x)

fiber : (A B : U) (f : A -> B) (y : B) -> U
fiber A B f y = Sigma A (\x -> Id B (f x) y)

pathTo : (A:U) -> A -> U
pathTo A = fiber A A (id A)

id : (A:U) -> A -> A
id A a = a

inv : (A : U) -> (a b :A) -> Id A a b -> Id A b a
inv A a b p = subst A (\ x -> Id A x a) a b p (refl A a)

sId : (A : U) (a : A) -> pathTo A a
sId A a = pair a (refl A a)

tId : (A : U) (a : A) (v : pathTo A a) -> Id (pathTo A a) (sId A a) v
tId A a = split 
  pair x p -> rem x a p 
  where 
  rem : (x y : A) (p : Id A x y) -> Id (pathTo A y) (sId A y) (pair x p)
  rem x = J A x (\y p -> Id (pathTo A y) (sId A y) (pair x p)) (refl (pathTo A x) (sId A x))

eqU : Id U U U
eqU = equivEq U U (id U) (sId U) (tId U)

data Bool = true | false

Bool' : U
Bool' = transport U U eqU Bool

eqBoolBool' : Id U Bool Bool'
eqBoolBool' = transpEquivEq U U (id U) (sId U) (tId U) Bool

eqBool'Bool : Id U Bool' Bool
eqBool'Bool = inv U Bool Bool' eqBoolBool'

true' : Bool'
true' = transport Bool Bool' eqBoolBool' true

newtrue : Bool
newtrue = transport Bool' Bool eqBool'Bool true'