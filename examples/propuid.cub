
eval test3 where


primitive
  Id   : (A : U) (a b : A) -> U
  refl : (A : U) (a : A) -> Id A a a
  ext  : (A : U) (B : (a:A) -> U) (f g : (a : A) -> B a)
         (p : ((x : A) -> (Id (B x) (f x) (g x)))) -> Id ((y : A) -> B y) f g
  J : (A : U) (a : A) -> (C : (x:A) -> Id A a x -> U) -> C a (refl A a) -> 
      (x:A) -> (p:Id A a x) -> C x p
  Jeq : (A : U) (a : A) -> (C : (x:A) -> Id A a x -> U) -> (d : C a (refl A a)) ->
        Id (C a (refl A a)) d (J A a C d a (refl A a))
  inh : U -> U
  inc : (A : U) -> A -> inh A
--  squash : (A : U) -> prop (inh A)
  squash : (A : U) (a b : inh A) -> Id (inh A) a b

subst : (A : U) (P : A -> U) (a x : A) (p : Id A a x) -> P a -> P x
subst A P a x p d = J A a (\ x q -> P x) d x p

substeq : (A : U) (P : A -> U) (a : A) (d : P a) -> 
          Id (P a) d (subst A P a a (refl A a) d)
substeq A P a d = Jeq A a (\ x q -> P x) d

cong : (A B : U) (f : A -> B) (a b : A) (p : Id A a b) -> Id B (f a) (f b)
cong A B f a b p = subst A (\x -> Id B (f a) (f x)) a b p (refl B (f a))

prop : U -> U
prop A = (a b : A) -> Id A a b

UIP : U -> U
UIP A = (a b : A) -> (p q : Id A a b) -> Id (Id A a b) p q

comp : (A : U) -> (a b c : A) -> Id A a b -> Id A b c -> Id A a c
comp A a b c p q = subst A (Id A a) b c q p 


compInvIdr : (A : U) -> (a b : A) -> (p : Id A a b) -> Id (Id A a b) p (comp A a b b p (refl A b))
compInvIdr A a b p = substeq A (\x -> Id A a x) b p

inv : (A : U) -> (a b :A) -> Id A a b -> Id A b a 
inv A a b p = subst A (\ x -> Id A x a) a b p (refl A a)


compIdr : (A : U) -> (a b : A) -> (p : Id A a b) -> Id (Id A a b) (comp A a b b p (refl A b)) p
compIdr A a b p = inv (Id A a b) p (comp A a b b p (refl A b)) (compInvIdr A a b p)


compInvIdl : (A : U) -> (b c : A) -> (q : Id A b c) ->
          Id (Id A b c) q (comp A b b c (refl A b) q)
compInvIdl A b c q = J A b (\c q -> Id (Id A b c) q (comp A b b c (refl A b) q)) rem c q
  where
    rem : Id (Id A b b) (refl A b) (comp A b b b (refl A b) (refl A b))
    rem = compInvIdr A b b (refl A b)


compIdl : (A : U) -> (b c : A) -> (q : Id A b c) -> 
             Id (Id A b c) (comp A b b c (refl A b) q) q
compIdl A b c q = inv (Id A b c) q (comp A b b c (refl A b) q) (compInvIdl A b c q)

compInvIdl' : (A : U) (a b : A) (p : Id A a b) -> 
               Id (Id A a b) p (compInv A a a b (refl A a) p)
compInvIdl' A a b p = substeq A (\x -> Id A x b) a p

compInv : (A : U) -> (a b c : A) -> Id A a b -> Id A a c -> Id A b c
compInv A a b c p r = subst A (\ x -> Id A x c) a b p r


lemTrans : (A:U) -> (a a' b b':A) -> Id A a a' -> Id A b b' -> Id A a b -> Id A a' b'
lemTrans A a a' b b' p q r = 
 subst A (\ x -> Id A x b') a a' p rem
 where 
  rem : Id A a b'
  rem = comp A a b b' r q 


lem2Trans : (A:U) -> (a a' b b':A) -> Id A a a' -> Id A b b' -> Id A a' b' -> Id A a b
lem2Trans A a a' b b' p q r = 
 subst A (\ x -> Id A a x) b' b (inv A b b' q) rem
 where
  rem : Id A a b'
  rem = comp A a a' b' p r 

--  J : (A : U) (a : A) -> (C : (x:A) -> Id A a x -> U) -> C a (refl A a) -> 
--      (x:A) -> (p:Id A a x) -> C x p

-- compIdl : (A : U) -> (b c : A) -> (q : Id A b c) -> 
--              Id (Id A b c) (comp A b b c (refl A b) q) q

lemInv : (A:U) -> (a b c : A) -> (p : Id A a b) -> (q : Id A b c) ->
         Id (Id A b c) q (compInv A a b c p (comp A a b c p q))
lemInv A a b c p q = 
 J A a (\ b p -> (c : A) (q : Id A b c) ->
        Id (Id A b c) q (compInv A a b c p (comp A a b c p q))) rem b p c q
 where
  rem1 : (c : A) (q : Id A a c) ->
          Id (Id A a c) (comp A a a c (refl A a) q)
                        (compInv A a a c (refl A a) (comp A a a c (refl A a) q)) 
  rem1 c q = compInvIdl' A a c (comp A a a c (refl A a) q)

  rem2 : (c : A) (q : Id A a c) -> Id (Id A a c) q (comp A a a c (refl A a) q)
  rem2 c q = compInvIdl A a c q

  rem : (c : A) (q : Id A a c) ->
          Id (Id A a c) q (compInv A a a c (refl A a) (comp A a a c (refl A a) q))
  rem c q = comp (Id A a c) q
                        (comp A a a c (refl A a) q)
                        (compInv A a a c (refl A a) (comp A a a c (refl A a) q))
                        (rem2 c q)
                        (rem1 c q)



lemSimpl : (A:U) -> (a b c : A) -> (p : Id A a b) -> (q q' : Id A b c) -> 
   Id (Id A a c) (comp A a b c p q) (comp A a b c p q') -> Id (Id A b c) q q'
lemSimpl A a b c p q q' h =
 lem2Trans (Id A b c) 
           q (compInv A a b c p (comp A a b c p q)) q' (compInv A a b c p (comp A a b c p q'))
           rem rem1 rem2
 where
   rem : Id (Id A b c) q (compInv A a b c p (comp A a b c p q)) 
   rem = lemInv A a b c p q

   rem1 : Id (Id A b c) q' (compInv A a b c p (comp A a b c p q'))
   rem1 = lemInv A a b c p q'

   rem2 : Id (Id A b c) (compInv A a b c p (comp A a b c p q))
                        (compInv A a b c p (comp A a b c p q'))
   rem2 = cong (Id A a c) (Id A b c) (compInv A a b c p)
               (comp A a b c p q) (comp A a b c p q') h

-- compInv : (A : U) -> (a b c : A) -> Id A a b -> Id A a c -> Id A b c  

-- lem2Trans : (A:U) -> (a a' b b':A) -> Id A a a' -> Id A b b' -> Id A a' b' -> Id A a b

-- lemInv : (A:U) -> (a b c : A) -> (p : Id A a b) -> (q : Id A b c) ->
--          Id (Id A b c) q (compInv A a b c p (comp A a b c p q))

lem1 : (A :U) -> (a:A) -> (h : (x:A) -> Id A a x) -> 
       (x y : A) -> (p : Id A x y) -> Id (Id A a y) (comp A a x y (h x) p) (h y)
lem1 A a h x =
  J A x (\ y p -> Id (Id A a y) (comp A a x y (h x) p) (h y)) rem
 where   
  rem : Id (Id A a x) (comp A a x x (h x) (refl A x)) (h x)
  rem = compIdr A a x (h x) 

lem2 : (A :U) -> (a:A) -> ((x:A) -> Id A a x) -> UIP A
lem2 A a h x y p q =
 lemSimpl A a x y (h x) p q rem
   where
      remp : Id (Id A a y) (comp A a x y (h x) p) (h y)
      remp = lem1 A a h x y p
      remq : Id (Id A a y) (comp A a x y (h x) q) (h y)
      remq = lem1 A a h x y q
      rem : Id (Id A a y) (comp A a x y (h x) p) (comp A a x y (h x) q)
      rem = lem2Trans (Id A a y) (comp A a x y (h x) p) (h y) (comp A a x y (h x) q) (h y)
                remp remq (refl (Id A a y) (h y))

lem3 : (A:U) -> prop A -> UIP A
lem3 A h a = lem2 A a (h a) a

data Unit = tt

propunit : prop Unit
propunit = split
  tt -> split
     tt -> refl Unit ($ tt)

lemunit : UIP Unit
lemunit = lem3 Unit propunit

test2 : Id (Id Unit ($ tt) ($ tt) ) (refl Unit ($ tt)) (refl Unit ($ tt))
test2 = lemunit($ tt) ($ tt)(refl Unit ($ tt))(refl Unit ($ tt))

inhuip : (A : U) -> UIP (inh A)
inhuip A = lem3 (inh A) (squash A)

data N = zero | suc (n : N)

zz : inh N
zz = inc N ($ zero)

eq1 : Id (inh N) zz zz
eq1 = refl (inh N) zz

eq2 : Id (inh N) zz zz
eq2 = squash N zz zz

test : Id (Id (inh N) zz zz) eq1 eq2
test = inhuip N zz zz eq1 eq2

data N0 =

neg : U -> U
neg A = A -> N0

efq : (A : U) -> N0 -> A
efq A = split {}

data or (A B : U) = inl (a : A) | inr (b : B)

dec : U -> U
dec A = or A (neg A)

data Sigma (A : U) (B : A -> U) = pair (x : A) (y : B x)

const : (A : U) (f : A -> A) -> U
const A f = (x y : A) -> Id A (f x) (f y)

exConst : (A : U) -> U
exConst A = Sigma (A -> A) (const A)

decConst : (A : U) -> dec A -> exConst A
decConst A = split
  inl a -> $ pair (\x -> a) (\ x y -> refl A a)
  inr h -> $ pair (\x -> x) (\ x y -> efq (Id A x y) (h x))


-- compIdr : (A : U) -> (a b : A) -> (p : Id A a b) -> Id (Id A a b) (comp A a b b p (refl A b)) p

  -- J : (A : U) (a : A) -> (C : (x:A) -> Id A a x -> U) -> C a (refl A a) -> 
  --     (x:A) -> (p:Id A a x) -> C x p

mainLemma : (A: U) (f : (a b : A) -> Id A a b -> Id A a b) (a b : A)
            (p : Id A a b) ->
	    Id (Id A a b) (comp A a a b (f a a (refl A a)) p) (f a b p)
mainLemma A f a = J A a (\ b p -> Id (Id A a b) (comp A a a b (f a a (refl A a)) p) (f a b p)) rem
  where rem : Id (Id A a a) (comp A a a a (f a a (refl A a)) (refl A a)) (f a a (refl A a))
        rem = compIdr A a a (f a a (refl A a))

discrete : U -> U
discrete A = (a b : A) -> dec (Id A a b)

fst : (A : U) (B : A -> U) -> Sigma A B -> A
fst A B = split
  pair a b -> a

snd : (A : U) (B : A -> U) (p : Sigma A B) -> B (fst A B p)
snd A B = split
  pair a b -> b

hedberg : (A : U) -> discrete A -> UIP A
hedberg A h a b p q = lemSimpl A a a b r p q rem5
  where rem1 : (x y : A) -> exConst (Id A x y)
        rem1 x y = decConst (Id A x y) (h x y)

        f : (x y : A) -> Id A x y -> Id A x y
        f x y = fst (Id A x y -> Id A x y) (const (Id A x y)) (rem1 x y)

        fisconst : (x y : A) -> const (Id A x y) (f x y)
        fisconst x y = snd (Id A x y -> Id A x y) (const (Id A x y)) (rem1 x y)

        r : Id A a a
        r = f a a (refl A a)

        rem2 : Id (Id A a b) (comp A a a b r p) (f a b p)
        rem2 = mainLemma A f a b p

        rem3 : Id (Id A a b) (comp A a a b r q) (f a b q)
	rem3 = mainLemma A f a b q

        rem4 : Id (Id A a b) (f a b p) (f a b q)
        rem4 = fisconst a b p q

        rem5 : Id (Id A a b) (comp A a a b r p) (comp A a a b r q)
        rem5 = lem2Trans (Id A a b) (comp A a a b r p) (f a b p) (comp A a a b r q) (f a b q) rem2 rem3 rem4



znots : (n : N) -> neg (Id N ($ zero) ($ suc n))
znots n h = subst N T ($ zero) ($ suc n) h ($ zero)
  where
    T : N -> U
    T = split
          zero -> N
          suc n -> N0

snotz : (n : N) -> neg (Id N ($ suc n) ($ zero))
snotz n h = znots n (inv N ($ suc n) ($ zero) h)

pred : N -> N
pred = split
  zero -> $ zero
  suc n -> n

sucInj : (n m : N) -> Id N ($ suc n) ($ suc m) -> Id N n m
sucInj n m h = cong N N pred ($ suc n) ($ suc m) h

sucCong : (n m : N) -> Id N n m -> Id N ($ suc n) ($ suc m)
sucCong n m h = cong N N (\n -> $ suc n) n m h

decEqCong : (A B : U) (f : A -> B) (g : B -> A) -> dec A -> dec B
decEqCong A B f g = split
  inl a -> $inl (f a)
  inr h -> $inr (\b -> h (g b))


natDec : discrete N
natDec = split
  zero  -> split
    zero -> rem
      where rem : dec (Id N ($ zero) ($ zero))
            rem = $ inl (refl N ($ zero))
    suc m -> $ inr (znots m)
  suc n -> split
    zero -> $ inr (snotz n)
    suc m -> decEqCong (Id N n m) (Id N ($ suc n) ($ suc m))
                       (sucCong n m) (sucInj n m) (natDec n m)

NIsSet : UIP N
NIsSet = hedberg N natDec

test3 : Id (Id N ($ zero) ($ zero)) (refl N ($ zero)) (refl N ($ zero))
test3 = NIsSet ($ zero) ($ zero) (refl N ($ zero)) (refl N ($ zero))
